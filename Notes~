-------- Collaborative Editor Project --------
1. Name ideas
2. Overall idea
3. Frontend considerations
3.1 - Structure
4. Request protocol
4.1 - Global requests
4.1.1 - List of global requests
4.2 - Document requests
4.2.1 - List of document requests

-------- Name ideas --------
Gutenborg

-------- Overall idea --------
When you go to the index web page, you are asked to pick a nickname and a color. There's also an option to let the server pick a color for you. (E. g. if you want to reuse the color you chose last time).
Then, the server registers you on their user list. It gives you a persistent numerical user ID (like 3 or 5) and a hexidecimal authentication cookie full of random gibberish. This cookie is your authentication. Every time you ask the server for something, you gotta use this cookie or else you'll get booted out. Nobody should know anyone else's authentication cookie.
When you've chosen a name and color and recieved an ID and a cookie, you are said to be "connected" to the server. When the server decides to void your authentication cookie (or when it doesn't work any more), you are said to be "Disconnected" from the server.
The server keeps track of who has connected over time and whether they are still online or not. This is so that if someone logs out, their color will not disappear. Perhaps the server can void the cookies of clients who haven't responded in half a minute, and can delete the entries from the user list of people who haven't connected in the past month or so.

After connecting to the server, you are provided with a user list and a list of documents. Any user can "subscribe" to any number of documents they want to (or none at all). When a user is "subscribed" to a document, they see all the changes the other users make in real-time and are given a representation of the document so they can make changes themselves. Their name will appear on that document's user list.

That's the high-level stuff; now down to the low-level gutsy things.
I'll use the word "Request" to denote something that's asked of the server and the word "Event" to talk about things that have changed that the server wants to tell you about.
There are two types of requests and events: Global level requests/events and document level requests/events. Global level events describe things that has happened to the server as a whole that everyone should know about; document-level events are things about a certain document that only concern that document. As such, they will only be sent to subscribers of that document.

Every time a request is sent to the server, the server sends events to every user, and (only) in the case of global events, to the user who asked the request.

Because we're going to need polling of some sort, a state will be kept track of. Two of

-------- Frontend design --------
--- Structure:
* Session
    * Collection of global user functions (change name, change color, etc.)
    * My user auth. cookie
    * My user ID
    * Global state
    * User records (array)
      * I. D. (NOT their auth cookie)
      * Name
      * Color
      * Online?
    * Subscribed Documents (array)
        * Collection of global document functions (change chunk, add chunk, etc.)
        * Document state (integer)
        * User IDs subscribed to this document (array)
        * Current state (This can be completely tracked with what's in the div)
            * Chunks
                * Author ID
                * Text

-------- Request protocol --------
A request is asking the server to do something. The server will always respond with a JSON object. There are two types of requests: Global requests and document-wide requests. The former deals with server-wide stuff; the latter deals only with changes to a single document's state. All requests will be sent to http://some-url.com/.../request

--- Global requests
The client will always ask the server requests in this form:
http://some-url.com/.../request?c= (Client's auth cookie) &r= (Request number) &p= (Request parameters)
The server will respond with a JSON object indicating acknowledgment and success or failure. [TODO: Explain] If the server's authentication cookie does not match the one the client provided, the client is immediately disconnected and removed from all subscribed documents.
----- List of global requests
* 1: New user online. Upon recieving this from the client, the server will add their cookie to the authentication database.

--- Document requests
The client will always ask the server requests in this form:
http://some-url.com/.../request?c= (Client's auth cookie) &d= (Document ID) &s= (Document state) &r= (Request number) &p= (Request parameters)
The server will respond with a JSON list of incoming requests from other clients ever since the specified document state. [TODO: Explain] If the server's authentication cookie does not match the one the client provided, the client is immediately disconnected and removed from all subscribed documents.
----- List of document requests


From notes by the w3c: http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#contenteditable
Five edge cases in particular need to be considered carefully when implementing this feature: backspacing at the start of an element, backspacing when the caret is immediately after an element, forward-deleting at the end of an element, forward-deleting when the caret is immediately before an element, and deleting a selection whose start and end points do not share a common parent node.
